# Contextual Query Language

This implementation of CQL for Polypheny was part of [Vishal Dalwadi's](https://github.com/VishalDalwadi)
Google Summer of Code 2021 project **Support for Contextual Query Language**. The features implemented are
explained below.

The initial design for CQL implementation was to allow users to create JARs that contain the context set
information. These JARs could then be found by a plugin manager and the CQL execution engine could use the
context sets to convert the query into relation algebra.

However, after careful consideration, we came upon the current design which is much simpler (both for
understanding and implementation). In the current design, the schema takes on the role of Context Set.
The schema has tables which in-turn have columns. These two take on the role of index (as specified in the
CQL standard spec). `Filters` are operations taking place on columns and `Relations` are the output of combine
operation ( Joins or Set Operations ) on tables.

### Table of Contents

* **[Basics](#basics)**
* **[Syntax](#syntax)**
* **[Future Plans and Nice-to-have features](#future-plans-and-nice-to-have-features)**

### Basics

Polypheny, currently, executes CQL query on its [REST interface](https://github.com/polypheny/Polypheny-DB/tree/master/rest-interface)
at route `GET /restapi/v1/cql`. The handler assumes the entire body to be the CQL query.

Polypheny's CQL implementation makes some changes and adds many extensions to the [CQL Specification](https://www.loc.gov/standards/sru/cql/spec.html).
It does not have prefix assignments or search-term-only filters. It also introduces some more keywords to add
more details in the query.

Polypheny's CQL implementation uses fully qualified names instead of indices in CQL standard. For example,
column names like `public.emps.emp` and table names like `public.emps`.

### Syntax

```
CQL Query:
    (
        [ Filters ]
    |
        [ relation Relation ]
    |
        [ Filters relation Relation ]
    )
    [ sortby Sort Specification ]
    [ project Projection ]    
```

- `Filters`: Filters are used to do comparisons on a column in the `Relation`. They are similar to SQL's WHERE clause.
If `Relation` is specified, the column must be from the relation specified. Comparisons can be between literal
values or columns; however, support for comparisons with columns is still underway. Comparisons like equals,
not equal, less than, greater than, less than or equals and greater than or equals can be done with support for
more (between, any, all, etc.) to be added later. Multiple filters can be separated by AND, OR, NOT or PROX boolean
operators; however, support for PROX is still underway. Boolean operators' precedence depend on their position; i.e.
First occurring boolean operator has higher precedence than those occurring later. However, this can be change by
using parenthesis.

- `Relation`: Relation is the final table that the query would be executed on. So the relation is a combination of
multiple tables. The combination operation can be a join, union, intersection, set-difference, etc; however, 
implementation of set operations as combiners is still underway. The actual combiner keyword used is AND or OR.
For joins, AND means a INNER join, whereas OR means a FULL, LEFT or RIGHT join. The combiner also takes modifiers
used to modify its execution. The two modifiers currently supported are: `null` and `on`.

  The `null` modifier is to be used with OR combiner to specify which of the rows can be null. Possible values of
  `null` modifier are: `both` (FULL join), `right` (LEFT join) or `left` (RIGHT join).

  The `on` modifier is used to specify the columns to join on. It only works if the column(s) belong to both the
tables. Possible values of `on` modifier are: `all` (finds the common columns between two tables; Default for AND),
`none` (Default for OR), comma-separated list of column names (for example, 'name,id').
  
- `Sort Specification`: Sort specification is used to specify a space separate column list on which to sort the query
output.

- `Projection`: Projection is used to specify the columns for the result. It is also used for aggregations and grouping.

Example queries:

- Find employee named "Loki":
`public.employee.empname == "Loki"`

- Find all employees in the HR department that are married:
`public.dept.deptname == "HR" and public.employee.married == TRUE`

- Find all employees from the HR or IT department:
`public.dept.deptname == "HR" and public.dept.deptname == "IT" relation public.employee and public.dept`

- Find all employees from all departments except HR:
`public.employee.empno >= 1 NOT public.dept.deptname == "HR"`

- Count the number of employees:
`relation public.employee project public.employee.empno/count`

- Get all the employee names sorted by date of birth:
`relation public.employee sortby public.employee.dob project public.employee.empname`

- Count the number of employees in each department:
`relation public.employee project public.employee.empno/count public.employee.deptno`

### Future Plans and Nice-to-have features

- Optimize Combiner's `getCommonColumns` by creating a cache.
- Support for Column Filters.
- Support for Set Operations.
- Support for proximity boolean operator.
- Support for querying the result of a query.
- Modifiers for Sorting, Projection and Filtering.
- Increase test coverage.
